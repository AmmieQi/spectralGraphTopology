#' helper function used to compute initial guesses
#' for the vector of weights of the Laplacian matrix
#' @param w0 string represeting which initial point to use.
#'        options are "qp" and "naive".
#' @param Sinv inverse of the sample covariance matrix.
w_init <- function(w0, Sinv) {
  if (is.character(w0)) {
    if (w0 == "qp") {
      R <- vecLmat(ncol(Sinv))
      qp <- quadprog::solve.QP(crossprod(R), t(R) %*% vec(Sinv), diag(ncol(R)))
      w0 <- qp$solution
    } else if (w0 == "naive") {
      w0 <- Linv(Sinv)
      w0[w0 < 0] <- 0
    }
  }
  return(w0)
}

#' Updates the value of w, the weight vector of the graph Laplacian
#'
#' @param w weight vector of the graph
#' @param Lw Laplacian matrix generated by the weight vector of the graph
#' @param U matrix whose columns represent the eigen vectors of the Laplacian
#' matrix in increasing order
#' @param β scalar that controls the strength of the regularization term
#' @param λ vector whose entries are the eigenvalues of the Laplacian in
#' increasing order
#' @param N number of nodes
#' @param Kmat matrix (see section 1.1 for its definition)
#'
#' @return the updated value of w
laplacian.w_update <- function(w, Lw, U, beta, lambda, n, Kmat) {
  grad_f <- Lstar(Lw - crossprod(sqrt(lambda) * t(U)) + Kmat / beta)
  w_update <- w - .5 * grad_f / n
  w_update[w_update < 0] <- 0
  return(w_update)
}


#' Updates the value of U, the matrix whose columns represent the eigen vectors
#' of the Laplacian in increasing order
#'
#' @param Lw Laplacian matrix generated by the weight vector of the graph
#' @param N dimension of each data sample
#' @param K number of components of the graph
#'
#' @return the updated value of U
laplacian.U_update <- function(Lw, n, k) {
  return(eigenvectors(Lw)[, (k+1):n])
}


#' Updates the value of lambda, the vector whose entries correspond to the
#' eigenvalues of the Laplacian matrix
#'
#' @param lb lower bound on the eigenvalues of the Laplacian matrix
#' @param ub upper bound on the eigenvalues of the Laplacian matrix
#' @param β scalar that controls the strength of the regularization term
#' @param U matrix whose columns represent the eigen vectors of the Laplacian
#' matrix in increasing order
#' @param Lw Laplacian matrix generated by the weight vector of the graph
#' @param N dimension of each data sample
#' @param K number of components of the graph
#'
#' @return the updated value of λ
laplacian.lambda_update <- function(lb, ub, beta, U, Lw, n, k) {
  q <- n - k
  d <- diag(t(U) %*% Lw %*% U)
  lambda <- .5 * (d + sqrt(d^2 + 4 / beta)) # unconstrained solution as initial point
  eps <- 1e-9
  condition <- c((lambda[q] - ub) <= eps,
                 (lambda[1] - lb) >= -eps,
                 (lambda[2:q] - lambda[1:(q-1)]) >= -eps)
  if (all(condition)) {
    return (lambda)
  } else {
    greater_ub <- lambda > ub
    lesser_lb <- lambda < lb
    lambda[greater_ub] <- ub
    lambda[lesser_lb] <- lb
  }
  condition <- c((lambda[q] - ub) <= eps,
                 (lambda[1] - lb) >= -eps,
                 (lambda[2:q] - lambda[1:(q-1)]) >= -eps)
  if (all(condition)) {
    return (lambda)
  } else {
    print(lambda)
    stop("eigenvalues are not in increasing order,
          consider increasing the value of beta")
  }
}


#' Updates the value of V, the matrix whose columns represent the eigenvectors
#' of the Adjacency in increasing order
#'
#' @param Lw Laplacian matrix generated by the weight vector of the graph
#' @param N number of nodes
#' @param K number of components of the graph
#'
#' @return the updated value of U
bipartite.V_update <- function(Aw, n, z) {
  V <- eigenvectors(Aw)
  return(cbind(V[, 1:(.5*(n - z))], V[, (1 + .5*(n + z)):n]))
}


#' Updates the value of w, the weight vector of the graph adjacency matrix
#'
#' @param w weight vector of the graph
#' @param Lw Laplacian matrix generated by the weight vector of the graph
#' @param U matrix whose columns represent the eigen vectors of the Laplacian
#' matrix in increasing order
#' @param β scalar that controls the strength of the regularization term
#' @param λ vector whose entries are the eigenvalues of the Laplacian in
#' increasing order
#' @param N number of nodes
#' @param Kmat matrix (see section 1.1 for its definition)
#'
#' @return the updated value of w
bipartite.w_update <- function(w, Aw, V, beta, psi, Kmat, J, Lips) {
  grad_h <- 2 * w - Astar(V %*% diag(psi) %*% t(V)) + Lstar(Kmat) / beta
  w_update <- w - (Lstar(inv_sympd(L(w) + J))/beta + grad_h) / (2 + Lips/beta)
  w_update[w_update < 0] <- 0
  return(w_update)
}


#' Updates the value of psi, the vector whose entries correspond to the
#' eigenvalues of the adjacency matrix
#'
#' @param V matrix whose columns represent the eigen vectors of the Laplacian
#' matrix in increasing order
#' @param Aw Adjacency matrix generated by the weight vector of the graph
bipartite.psi_update <- function(V, Aw, lb = -Inf, ub = Inf) {
  c <- diag(t(V) %*% Aw %*% V)
  n <- length(c)
  c_tilde <- .5 * (rev(c[(n/2 + 1):n]) - c[1:(n/2)])
  x <- isoreg(rev(c_tilde))$yf
  x <- c(-rev(x), x)
  x[x < lb] = lb
  x[x > ub] = ub
  return(x)
}


dregular.w_update <- function() {
}


dregular.U_update <- function(Lw, n) {
  return(laplacian.U_update(Lw, n, k = 1))
}


dregular.lambda_update <- function(...) {
  return(laplacian.lambda_update(...))
}


joint.w_update <- function(w, Lw, Aw, U, V, lambda, psi, beta1, beta2, K) {
  n <- ncol(Lw)
  ULmdUT <- crossprod(sqrt(lambda) * t(U))
  VPsiVT <- V %*% diag(psi) %*% t(V)
  grad_f1 <- beta1 * Lstar(Lw - ULmdUT + K / beta1)
  grad_f2 <- beta2 * Astar(Aw - VPsiVT)
  w_update <- w - .5 * (grad_f1 + grad_f2) / (n * beta1 + beta2)
  w_update[w_update < 0] <- 0
  return(w_update)
}


joint.U_update <- function(...) {
  return(laplacian.U_update(...))
}


joint.V_update <- function(...) {
  return(bipartite.V_update(...))
}


joint.lambda_update <- function(...) {
  return(laplacian.lambda_update(...))
}


joint.psi_update <- function(...) {
  return(bipartite.psi_update(...))
}
