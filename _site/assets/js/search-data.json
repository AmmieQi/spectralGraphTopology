{
  "1": {
    "id": "1",
    "title": "Animals",
    "content": "Animals Animal dataset Animal dataset In this animal dataset (B. M. Lake an J. B. Tenenbaum 2010), there are 102 features which are binary answers to questions such as “Does it has feathers?”, “Is it warm-blooded?”, etc. There are in total 33 animals to be clustered. library(viridis) library(spectralGraphTopology) library(igraph) # read data df &lt;- read.csv(&quot;animals.txt&quot;, header = FALSE) names &lt;- matrix(unlist(read.csv(&quot;animals_names.txt&quot;, header = FALSE))) Y &lt;- matrix(as.numeric(unlist(df)), nrow = nrow(df)) n &lt;- nrow(Y) # estimate graph graph &lt;- learn_k_component_graph(cov(t(Y)) + diag(1/3, n, n), w0 = &quot;qp&quot;, beta = 1, k = 10, verbose = FALSE) # build network net &lt;- graph_from_adjacency_matrix(graph$Adjacency, mode = &quot;undirected&quot;, weighted = TRUE) # colorify edges colors &lt;- viridis(50, begin = 0, end = 1, direction = -1) c_scale &lt;- colorRamp(colors) E(net)$color = apply(c_scale(abs(E(net)$weight) / max(abs(E(net)$weight))), 1, function(x) rgb(x[1]/255, x[2]/255, x[3]/255)) V(net)$color = &quot;pink&quot; # plot network plot(net, vertex.label = names, vertex.size = 4, vertex.label.dist = 1, vertex.label.family = &quot;Helvetica&quot;, vertex.label.cex = .8, vertex.label.color = &quot;black&quot;) Lake, Brendan and Joshua Tenenbaum. “Discovering Structure by Learning Sparse Graphs.” Proceedings of the 32nd Annual Meeting of the Cognitive Science Society CogSci 2010, Portland, Oregon, United States, 11-14 August, 2010, Cognitive Science Society, Inc., 2010. pp. 778-784.",
    "url": "http://localhost:4000/spectralGraphTopology/docs/clustering/animals/",
    "relUrl": "/docs/clustering/animals/"
  },
  "2": {
    "id": "2",
    "title": "Bipartite",
    "content": "Bipartite library(spectralGraphTopology) library(igraph) library(viridis) library(corrplot) set.seed(42) # define number of nodes on each set n1 &lt;- 10 n2 &lt;- 6 n &lt;- n1 + n2 # define the probability of connection among nodes of different sets pc &lt;- .9 # sample a bipartite graph bipartite &lt;- sample_bipartite(n1, n2, type=&quot;Gnp&quot;, p = pc, directed=FALSE) # randomly assign edge weights to connected nodes E(bipartite)$weight &lt;- runif(gsize(bipartite), min = 0, max = 1) # get true Laplacian and Adjacency Ltrue &lt;- as.matrix(laplacian_matrix(bipartite)) Atrue &lt;- diag(diag(Ltrue)) - Ltrue # get samples Y &lt;- MASS::mvrnorm(100 * n, rep(0, n), Sigma = MASS::ginv(Ltrue)) # compute sample covariance matrix S &lt;- cov(Y) # estimate Adjacency matrix graph &lt;- learn_bipartite_graph(S, z = 4, verbose = FALSE) graph$Adjacency[graph$Adjacency &lt; 1e-3] &lt;- 0 # Plot Adjacency matrices: true and estimated corrplot(Atrue / max(Atrue), is.corr = FALSE, method = &quot;square&quot;, addgrid.col = NA, tl.pos = &quot;n&quot;, cl.cex = 1.25) corrplot(graph$Adjacency / max(graph$Adjacency), is.corr = FALSE, method = &quot;square&quot;, addgrid.col = NA, tl.pos = &quot;n&quot;, cl.cex = 1.25) # build networks estimated_bipartite &lt;- graph_from_adjacency_matrix(graph$Adjacency, mode = &quot;undirected&quot;, weighted = TRUE) V(estimated_bipartite)$type &lt;- c(rep(0, 10), rep(1, 6)) la = layout_as_bipartite(estimated_bipartite) colors &lt;- viridis(20, begin = 0, end = 1, direction = -1) c_scale &lt;- colorRamp(colors) E(estimated_bipartite)$color = apply(c_scale(E(estimated_bipartite)$weight / max(E(estimated_bipartite)$weight)), 1, function(x) rgb(x[1]/255, x[2]/255, x[3]/255)) E(bipartite)$color = apply(c_scale(E(bipartite)$weight / max(E(bipartite)$weight)), 1, function(x) rgb(x[1]/255, x[2]/255, x[3]/255)) la = la[, c(2, 1)] # Plot networks: true and estimated plot(bipartite, layout = la, vertex.color=c(&quot;red&quot;,&quot;black&quot;)[V(bipartite)$type + 1], vertex.shape = c(&quot;square&quot;, &quot;circle&quot;)[V(bipartite)$type + 1], vertex.label = NA, vertex.size = 5) plot(estimated_bipartite, layout = la, vertex.color=c(&quot;red&quot;,&quot;black&quot;)[V(estimated_bipartite)$type + 1], vertex.shape = c(&quot;square&quot;, &quot;circle&quot;)[V(estimated_bipartite)$type + 1], vertex.label = NA, vertex.size = 5) True adjacency Estimated adjacency True graph Estimated graph",
    "url": "http://localhost:4000/spectralGraphTopology/docs/structured/bipartite/",
    "relUrl": "/docs/structured/bipartite/"
  },
  "3": {
    "id": "3",
    "title": "Block bipartite",
    "content": "Block bipartite library(spectralGraphTopology) library(igraph) library(viridis) library(corrplot) set.seed(42) # design sythetic graph w &lt;- c(1, 0, 0, 1, 0, 1) * runif(6) Laplacian &lt;- block_diag(L(w), L(w)) Atrue &lt;- diag(diag(Laplacian)) - Laplacian # create graph from Adjacency matrix bipartite &lt;- graph_from_adjacency_matrix(Atrue, mode = &quot;undirected&quot;, weighted = TRUE) n &lt;- ncol(Laplacian) # sample data from GMRF Y &lt;- MASS::mvrnorm(40 * n, rep(0, n), MASS::ginv(Laplacian)) # learn graph on the basis of sampled data graph &lt;- learn_bipartite_k_component_graph(cov(Y), k = 2, beta = 1e2, nu = 1e2, verbose = FALSE) graph$Adjacency[graph$Adjacency &lt; 1e-2] &lt;- 0 # Plot Adjacency matrices: true and estimated corrplot(Atrue / max(Atrue), is.corr = FALSE, method = &quot;square&quot;, addgrid.col = NA, tl.pos = &quot;n&quot;, cl.cex = 1.25) corrplot(graph$Adjacency / max(graph$Adjacency), is.corr = FALSE, method = &quot;square&quot;, addgrid.col = NA, tl.pos = &quot;n&quot;, cl.cex = 1.25) # Build networks estimated_bipartite &lt;- graph_from_adjacency_matrix(graph$Adjacency, mode = &quot;undirected&quot;, weighted = TRUE) V(bipartite)$type &lt;- rep(c(TRUE, FALSE), 4) V(estimated_bipartite)$type &lt;- rep(c(TRUE, FALSE), 4) la = layout_as_bipartite(estimated_bipartite) colors &lt;- viridis(20, begin = 0, end = 1, direction = -1) c_scale &lt;- colorRamp(colors) E(estimated_bipartite)$color = apply(c_scale(E(estimated_bipartite)$weight / max(E(estimated_bipartite)$weight)), 1, function(x) rgb(x[1]/255, x[2]/255, x[3]/255)) E(bipartite)$color = apply(c_scale(E(bipartite)$weight / max(E(bipartite)$weight)), 1, function(x) rgb(x[1]/255, x[2]/255, x[3]/255)) la = la[, c(2, 1)] # Plot networks: true and estimated plot(bipartite, layout = la, vertex.color = c(&quot;red&quot;,&quot;black&quot;)[V(bipartite)$type + 1], vertex.shape = c(&quot;square&quot;, &quot;circle&quot;)[V(bipartite)$type + 1], vertex.label = NA, vertex.size = 5) plot(estimated_bipartite, layout = la, vertex.color = c(&quot;red&quot;,&quot;black&quot;)[V(estimated_bipartite)$type + 1], vertex.shape = c(&quot;square&quot;, &quot;circle&quot;)[V(estimated_bipartite)$type + 1], vertex.label = NA, vertex.size = 5) True adjacency Estimated adjacency True graph Estimated graph",
    "url": "http://localhost:4000/spectralGraphTopology/docs/structured/block-bipartite/",
    "relUrl": "/docs/structured/block-bipartite/"
  },
  "4": {
    "id": "4",
    "title": "Clustering",
    "content": "Clustering By estimating the Laplacian matrix of a k-component graph, spectralGraphTopology may reveal interesting connections among nodes. Let’s check out a few examples on classicals and real datasets.",
    "url": "http://localhost:4000/spectralGraphTopology/docs/clustering",
    "relUrl": "/docs/clustering"
  },
  "5": {
    "id": "5",
    "title": "Grid",
    "content": "Grid library(spectralGraphTopology) library(igraph) library(viridis) set.seed(0) # number of nodes p &lt;- 64 # build grid graph grid &lt;- make_lattice(length = sqrt(p), dim = 2) # number of observations n &lt;- as.integer(100 * p) # assign random weights to edges E(grid)$weight &lt;- runif(gsize(grid), min = 1e-1, max = 3) # compute true Laplacian and Adjacency matrices Ltrue &lt;- as.matrix(laplacian_matrix(grid)) Wtrue &lt;- diag(diag(Ltrue)) - Ltrue # sample data from grid graph Y &lt;- MASS::mvrnorm(n, mu = rep(0, p), Sigma = MASS::ginv(Ltrue)) # compute sample covariance matrix S &lt;- cov(Y) # learn graph on the basis of the observed data graph &lt;- learn_k_component_graph(S, w0 = &quot;qp&quot;, beta = 20, alpha = 5e-3, abstol = 1e-5, verbose = FALSE) graph$Adjacency[graph$Adjacency &lt; 5e-2] &lt;- 0 # build estimated graph estimated_grid &lt;- graph_from_adjacency_matrix(graph$Adjacency, mode = &quot;undirected&quot;, weighted = TRUE) # colorify graph colors &lt;- viridis(20, begin = 0, end = 1, direction = -1) c_scale &lt;- colorRamp(colors) E(estimated_grid)$color = apply(c_scale(E(estimated_grid)$weight / max(E(estimated_grid)$weight)), 1, function(x) rgb(x[1]/255, x[2]/255, x[3]/255)) E(grid)$color = apply(c_scale(E(grid)$weight / max(E(grid)$weight)), 1, function(x) rgb(x[1]/255, x[2]/255, x[3]/255)) V(estimated_grid)$color = &quot;grey&quot; V(grid)$color = &quot;grey&quot; la &lt;- layout_on_grid(grid) # plot graph plot(grid, layout = la, vertex.label = NA, vertex.size = 3) plot(estimated_grid, layout = la, vertex.label = NA, vertex.size = 3) True grid graph Learned grid graph",
    "url": "http://localhost:4000/spectralGraphTopology/docs/structured/grid/",
    "relUrl": "/docs/structured/grid/"
  },
  "6": {
    "id": "6",
    "title": "Home",
    "content": "Learning graphs from data via spectral constraints spectralGraphTopology provides estimators of the Laplacian and adjacency matrices of graphs by leveraging prior information in their structural form. Get started now View it on GitHub Getting started Dependencies The R version of spectralGraphTopology is build on top of awesome R packages including Rcpp, RcppEigen, and igraph. All these packages can be installed via CRAN. Installation The stable version can be installed via CRAN as &gt; install.packages(&quot;spectralGraphTopology&quot;) The development version can be installed via GitHub as devtools::install_github(&quot;dppalomar/spectralGraphTopology&quot;) You must have previously installed the devtools package. Tutorials See the package vignette for a detailed description of the mathematical methods that are available in spectralGraphTopology. About the project spectralGraphTopology is developed on GitHub by Ze Vinicius, Daniel Palomar, Jiaxi Ying and Sandeep Kumar. License spectralGraphTopology is distributed by an GPL 3.0 License. Contributing We welcome all sorts of contributions. Please feel free to open an issue to report a bug or discuss a feature request in our GitHub repo. Citation If this package has been useful to you in any way, give us a star on GitHub :) Additionally, if you’ve used spectralGraphTopology on your research, please consider citing the following resource: S. Kumar, J. Ying, J. V. de M. Cardoso and D. P. Palomar (2019). A unified framework for structured graph learning via spectral constraints. https://arxiv.org/pdf/1904.09792.pdf",
    "url": "http://localhost:4000/spectralGraphTopology/",
    "relUrl": "/"
  },
  "7": {
    "id": "7",
    "title": "Structured graphs",
    "content": "Structured graphs Let’s investigate how we can learn a graph with a given structure, from simple single models to k-component graphs.",
    "url": "http://localhost:4000/spectralGraphTopology/docs/structured",
    "relUrl": "/docs/structured"
  },
  "8": {
    "id": "8",
    "title": "Two moon",
    "content": "Two moon Two moon dataset Two moon dataset library(spectralGraphTopology) library(clusterSim) library(igraph) set.seed(42) # number of nodes per cluster n &lt;- 50 # generate datapoints twomoon &lt;- shapes.two.moon(n) # number of components k &lt;- 2 # compute sample correlation matrix S &lt;- crossprod(t(twomoon$data)) # estimate underlying graph graph &lt;- learn_k_component_graph(S, k = k, beta = .5, verbose = FALSE, abstol = 1e-3) # build network net &lt;- graph_from_adjacency_matrix(graph$Adjacency, mode = &quot;undirected&quot;, weighted = TRUE) # colorify nodes and edges colors &lt;- c(&quot;#706FD3&quot;, &quot;#FF5252&quot;) V(net)$cluster &lt;- twomoon$clusters E(net)$color &lt;- apply(as.data.frame(get.edgelist(net)), 1, function(x) ifelse(V(net)$cluster[x[1]] == V(net)$cluster[x[2]], colors[V(net)$cluster[x[1]]], &#39;#000000&#39;)) V(net)$color &lt;- colors[twomoon$clusters] # plot nodes plot(net, layout = twomoon$data, vertex.label = NA, vertex.size = 3)",
    "url": "http://localhost:4000/spectralGraphTopology/docs/clustering/twomoon/",
    "relUrl": "/docs/clustering/twomoon/"
  }
  
}
